
#+TITLE Ergo workman / norman

* Предупреждение

  Раскладка workman замечательна сама по себе, но практически полное отсутсвие 
  её поддержки, делает жизнь с ней мучительной. 
 
  Если ты, вдруг решили её попопробовать, послушай меня - ОСТАНОВИСЬ ГЛУПЕЦ!
  Спокойно работай на своем qwerty / dvorak / colemak.
  
  *ДАЖЕ НЕ ДУМАЙ! Я СЕРЬЁЗНО!*
  
  Не обрекай себя на этот кошмар! Чтобы комфортно работать с workman тебе 
  придется потратить уйму времени и стать гуру в конфигурировании клавиатур
  В каждой операционной системе которую ты используешь.
  
  Оно тебе надо?
  
  После многих лет её использования я не порекомендую workman никому!
  
  - Отсутсвие системной поддержки win / osx / linux, мне пришлось разбираться и
    писать её самому
  - Альтернативный язык / раскладка - тебе придется спроектировать свою новую
    раскладку под родной язык
  - Перманентный ребиндинг во всех приложениях
  - Ты выглядишь полным глупо, когда пытаешься что-то набрать на обычной
    клавиатуре
  
  Мои раскладки:
 
  - windows
  - OSX
  - Linux
    - Arch
    - Debian

** TODO Проблема переключения на другой язык
   
   При переключении раскладки на кирилицу символьные биндинги меняют своё
   положение.
   
   Необходимо разобраться, как определяется транслсяция латинских биндигов в
   языковые. Есть предположение, что это возможно происходит с помощью
   конфигурации геометрии.
* Ergo layout
  
  Я довольно давно виду гит-репозиторий с различными настройками биндингов под
  workman Данные биндинги скорее отражают мои привычки и плохо
  системотизированы.

  Столкнувшись недавно с проектом Xah Lee, ergo-mode, представляющй из себя
  переосмысление стандартных биндигов emacs, я был очень впечатлен проделанной
  работой, на которую у меня никогда не хватало духа, и я нашел его видение
  довольно близким мне по духу - кроме схожих комбинаций для перемещения, Xah
  Lee проработал биндинги редактирования, опираясь на статистику используемых в
  emacs комманд. Представьте моё удивление когда среди поддерживаемых раскладок
  я обнаружил workman!
  
  В рамках данного проекта предпологается взять разработанный Xah Lee лайаут
  операций над текстом и по мере возможности распространить его на различные
  системы помимо emacs, чем я безсистемно занимался последние годы.

** вынос ctrl / alt / altgr / esc
   
   В связи с тем, что агрегация управления курсором в область home-row сопряжена
   с активным использованием клавиш модификаторов, необходимо обратить
   внимание на их положение. 

   Традиционное расположение под ладнонью, *alt*, *ctrl*, *win* и т.д., вынуждает при
   их использовании выворачивать либо мизинец, либо большой палец с движением
   запястья.
   
   Оптимальным было бы сужение пробела, но это к сожалению встречается на очень
   редких клавиатурах. Альтернативой является перенос модификаторов под
   мизинцы 
   - слева: caps, tab, (shift на месте), 
   - справа: [, ', /

** TODO Приложения
*** vim / neovim
*** emacs / spacemacs
*** nano
*** zsh / bash / fish / ..
*** midnight commander
* Workman for coders
  
  По аналогии colemak for coders предпологаетсяя добавление в workman AltGr слоя
  со спец-символами перенесеннымй ближе к home-row

- цифры хорошее место для редких юникод-символов, стрелки, параграфы и т.д.

- Далеко располооженные символы

  | скобки      | операторы       |
  |-------------+-----------------|
  | ( ) { } [ ] | + - * =         |
  |             | ~ ! @ # $ % ^ & |


  workman for coders

  ┌────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────────┐
  │ `  │ 1   │ 2   │ 3   │ 4   │ 5   │ 6   │ 7   │ 8   │ 9   │ 0   │ ─   │ =   │ BS     │
  │ ~  │ !   │ @   │ #   │ $   │ %   │ ^   │ &   │ *   │ (   │ )   │ _   │ +   │        │
  ├────┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬─────┤
  │Tab    │ q 1 │ d 2 │ r 3 │ w 4 │ b 5 │ j ╳╳│ f ╳╳│ u 6 │ p 7 │ ; 8 │ [ 9 │ ] 0 │ \   │
  │       │ Q   │ D   │ R   │ W   │ B   │ J ╳╳│ F ╳╳│ U   │ P   │ :   │ {   │ }   │ |   │
  ├───────┴─┲━━━┷━┳━━━┷━┳━━━┷━┳━━━┷━┱───┴─┬───┴─┲━━━┷━┳━━━┷━┳━━━┷━┳━━━┷━┱───┴─┬───┴─────┤
  │Backspace┃ a { ┃ s } ┃ h ( ┃ t ) ┃ g ! │ y $ ┃ n ─ ┃ e + ┃ o * ┃ i \ ┃ ' ` │Enter    │
  │         ┃ A   ┃ S   ┃ H   ┃ T   ┃ G   │ Y   ┃ N   ┃ E   ┃ O   ┃ I   ┃ "   │         │
  ├─────────┺━━┯━━┻━━┯━━┻━━┯━━┻━━┯━━┹──┬──┴──┬──┺━━┯━━┻━━┯━━┻━━┯━━┻━━┯━━┹──┬──┴─────────┤
  │Shift       │ z @ │ x # │ m [ │ c ] │ v = │ k ╳╳│ l _ │ , ^ │ . & │ / % │ Shift      │
  │            │ Z   │ X   │ M   │ C   │ V   │ K ╳╳│ L   │ <   │ >   │ ?   │            │
  ├──────┬─────┼─────┼─────┼─────┴─────┴─────┴─────┴─────┼─────┼─────┼─────┼────────────┤
  │Ctrl  │Fn   │Win  │Alt  │                             │Alt  │Menu │Ctrl │            │
  │      │     │     │     │                             │gr   │     │     │            │ 
  └──────┴─────┴─────┴─────┴─────────────────────────────┴─────┴─────┴─────┴────────────┘


  ┌────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────────┐
  │ `  │ 1   │ 2   │ 3   │ 4   │ 5   │ 6   │ 7   │ 8   │ 9   │ 0   │ ─   │ =   │ BS     │
  │ ~  │ !   │ @   │ #   │ $   │ %   │ ^   │ &   │ *   │ (   │ )   │ _   │ +   │        │
  ├────┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬─────┤
  │Tab    │     │  bs │   ↑ │ del │     │ ╳╳╳ │ ╳╳╳ │   @ │   # │ ; $ │ [ & │ ]   │ \   │
  │       │     │     │pgup │     │     │ ╳╳╳ │ ╳╳╳ │     │     │ :   │ {   │ }   │ |   │
  ├───────┴─┲━━━┷━┳━━━┷━┳━━━┷━┳━━━┷━┱───┴─┬───┴─┲━━━┷━┳━━━┷━┳━━━┷━┳━━━┷━┱───┴─┬───┴─────┤
  │Backspace┃home ┃   ← ┃   ↓ ┃   → ┃ end │   _ ┃   ! ┃   = ┃     ┃   ~ ┃ ' ` │Enter    │
  │         ┃     ┃     ┃pgdn ┃     ┃     │     ┃     ┃     ┃     ┃     ┃ "   │         │
  ├─────────┺━━┯━━┻━━┯━━┻━━┯━━┻━━┯━━┹──┬──┴──┬──┺━━┯━━┻━━┯━━┻━━┯━━┻━━┯━━┹──┬──┴─────────┤
  │Shift       │   { │   } │   ( │   ) │ ╳╳╳ │   - │   + │ , ^ │ . * │ / % │ Shift      │
  │            │     │     │     │     │ ╳╳╳ │     │     │ <   │ >   │ ?   │            │
  ├──────┬─────┼─────┼─────┼─────┴─────┴─────┴─────┴─────╔═════╗─────┼─────┼────────────┤
  │Ctrl  │Fn   │Win  │Alt  │                             ║Alt  ║Menu │Ctrl │            │
  │      │     │     │     │                             ║Gr   ║     │     │            │
  └──────┴─────┴─────┴─────┴─────────────────────────────╚═════╝─────┴─────┴────────────┘
* xkb
  
  X Keyboard Extension  
  Модуль Х11 обслуживающий клавиатуру
  https://wiki.archlinux.org/index.php/X_KeyBoard_extension

  Отличное описание сделал Иван Паскаль
  http://pascal.tsu.ru/other/xkb/setup.html

  Также есть неплохая статья на хабре
  https://habrahabr.ru/post/222285/

** Порядок настройки

   - Группировка по функциям
     - новые модификаторы
       - tab caps shift
       - [ ] ' /
       - space
     - перемещение курсора
     - перемещения мыши
     - спецсимволы для программирования
** Терминология
   
   - *symbols* - список символов привязанный к сканкоду, разбит на группы
   - *group* - переключаемая группа symbols / как правило языковая раскладка,
     содержит список символов для различных "уровней сдвига"
   - *shift level* - уровень сдвига символа, задаваемый модификаторами, простейший
     случай смена символа на заглавный при нажатии shift
   - *latch* - разовое залипание модификатора
   - *lock* - постоянное залипание модификатора
   - 
** Назначение секций настоек

   При старте X-сервера, модуль XKB зачитывает все необходимые данные из
   текстовых файлов, которые образуют "базу данных" настроек XKB.

   /usr/share/X11/xkb
   
   Строго говоря, большинство из этих файлов сам модуль XKB не читает. Он
   вызывает программу xkbcomp, которая переводит содержимое этих файлов в
   двоичный формат, понятный непосредственно модулю XKB.

   Но для настройки это не так уж важно, поскольку вызов xkbcomp происходит
   автоматически, незаметно для пользователя.

   База данных, необходимых XKB, состоит из 5 компонентов

   | keycodes      | наименование сканкодов           |
   | types         | определяет влияние модификаторов |
   | compatibility | определяет экшены                |
   | symbols       | таблицы keysym                   |
   | geometry      | практически ни на что не влияет  |
  
   - keycodes
     таблицы, которые просто задают символические имена для скан-кодов.
     Например
     <TLDE>= 49;
     <AE01> = 10;
 
   - types 
     описывает типы клавиш. Тип клавиши определяет - как должно меняться
     значение, выдаваемое клавишей в зависимости от модификаторов (Control,
     Shift и т.п.). Так, например, "буквенные" клавиши относятся к типу
     ALPHABETIC, что означает, что они имеют разное значение в зависимости от
     состояния Shift и CapsLock. А клавиша [Enter] имеет тип - ONE_LEVEL, что
     означает, что ее значение всегда одно и то же, независимо от состояния
     модификаторов.

   - compat (сокращенное от compability) 
     описывает "поведение" модификаторов. В
     XKB имеется несколько внутренних переменных, которые, в конечном счете, и
     определяют - какой символ будет генерироваться при нажатии клавиши в
     конкретной ситуации. Так вот, в compat как-раз описывается - как должны
     меняться эти переменные при нажатии различных клавиш-модификаторов. В этом
     же разделе обычно описывается и поведение "лампочек"-индикаторов на
     клавиатуре.

   - symbols 
     таблицы, в которых для каждого скан-кода (имени скан-кода,
     определенного в keycodes) перечисляются все значения (symbols), которые
     должна выдавать клавиша. Естественно, количество различных значений зависит
     от типа клавиши (котрые описываются в types), а какое именно значение будет
     выдано в конкретной ситуации, определяется состоянием модификаторов и их
     "поведением" (которое описывается в compat)

   - geometry 
     описывает "геометрию" клавиатуры - то есть расположение клавиш на
     клавиатуре. Эти описания нужны не столько самому X-серверу, сколько
     прикладным программам, которые рисуют изображение клавиатуры.

   #+BEGIN_SRC C
   xkb_keymap {
      xkb_keycodes      { include "..." };
      xkb_types         { include "..." };
      xkb_compatibility { include "..." };
      xkb_symbols       { include "..." };
      xkb_geometry      { include "..." };
   }
   #+END_SRC

** Трансляция кода нажатой клавиши
  
   В общем процесс выглядит так:
  
   (keycode, group, state) → keysym
   
   | keycode | сканкод клавиши          |
   | group   | текущий лайаут           |
   | state   | биты модификаторов       |
   |---------+--------------------------|
   | keysym  | транслированное значение |

   Более детально:
 
   1. (keycode [, group]) → type
   2. (state, type) → level
   3. (keycode, group, level) → S[keycode][group][level]

   Где S - таблица xkb_symbols
  
   type - используется для того, чтобы определить, какие модификаторы на какие
   клавиши влияют. В целом type необходим, чтобы сократить размер таблицы S.

** Структура symbols
   
   Напомню, чтос каждой клавишей связана таблица символов (symbols). Эта таблица
   делится на под-таблицы - группы (group), выбор конкретной группы зависит от
   текущего номера группы в "состоянии клавиатуры". Каждая группа, в свою
   очередь делится на колонки - уровни (shift level), выбор уровня зависит от
   типа клавиши (type) в данной группе и состояния модификаторов.
   
   - symbols
     - group
     - shift levels

   #+BEGIN_SRC C 
   //            group1          group2
   key <name> { [g1_l1, g1_l2], [g2_l1, g2_l2, g2_l3, g2_l4] };
   #+END_SRC

** Экшены

   Кейсим может активировать экшн, например установка бита модификатора.
   (keysym, state) → action

** Compose key
   
   Модификатор позволяющий вводить юникод символы по названю

   compose c c c p → ☭
   http://cgit.freedesktop.org/xorg/lib/libX11/plain/nls/en_US.UTF-8/Compose.pre

** Утилиты

   http://pascal.tsu.ru/other/xkb/programs.html

*** xkbcomp
    
    Это самая важная программа. Во всяком случае, она отрабатывет каждый раз при
    старте "иксов" для того, чтобы перевести файлы конфигурации XKB в бинарный
    формат, понятный самому X-серверу. (Как понятно из названия, это - "XKB
    compiler").

    Но более полезно то, что ее можно вызвать и "вручную". При этом, она может
    выполнять и обратное преобразование - из бинарной формы в "человекочитаемый"
    конфигурационный файл. И что самое полезное - она может обмениваться данными
    (записывать и читать) непосредственно с работающим X-сервером.

    То есть, ее можно использовать для того, чтобы в ходе работы загрузить новую
    конфигурацию XKB в X-сервер, или наоборот - прочитать текущую конфигурацию и
    перевести ее в "читабельный" формат.

    Последнее тоже важно. Поскольку полная конфигурация складывается из
    содержимого многих файлов/блоков (не забудьте, что в любом файле может быть
    'include'), понять - что же должно получится в результате такого
    "сложения" - не так-то просто. С помощью xkbcomp можно "вытащить" из
    X-сервера "суммарную" конфигурацию (в виде полной xkb_keymap).

    Полную информацию о xkbcomp можно прочитать в соответствующем man'е.
    Поэтому, приведу лишь примеры - как можно "обменяться информацией" с
    X-сервером. Вообще-то, если в качестве источника или приемника данных надо
    указать X-сервер, это можно сделать (как сказано в man X) в форме

    вывод текущего конфига
    > setxkbmap -print
   
*** setxkbmap
    
    Утилита управления элементами конфига 


*** xev
    выводит события клавиатуры

*** xkbprint
    генератор изображения клавиатуры
    > xkbprint -o keyboard.ps :0.0
    > gs keyboard.ps
** курсор мыши

   Управление курсором с цифровой клавиатуры может быть включено следующим
   образом:

   > setxkbmap -option keypad:pointerkeys
   
   добавляет в xkb_symbols { include "keypad(pointerkeys)" }   
   Управление курсором включается через *shift+numlock*
   
** объявление новых модификаторов

*** intelij / clion / eclipse

* Docs
  - http://pascal.tsu.ru/other/xkb/setup.html
  - https://habrahabr.ru/post/222285/
  - https://www.x.org/wiki/XKB/
  - https://www.freedesktop.org/wiki/Software/XKeyboardConfig/
  - https://wiki.archlinux.org/index.php/Keyboard_configuration_in_Xorg

Название Симоволов можно подсмотреть здесь:
   /usr/include/X11/keysymdef.h
